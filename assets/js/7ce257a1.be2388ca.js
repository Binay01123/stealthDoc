"use strict";(globalThis.webpackChunktemp_docusaurus=globalThis.webpackChunktemp_docusaurus||[]).push([[966],{5608:(n,e,o)=>{o.r(e),o.d(e,{assets:()=>s,contentTitle:()=>l,default:()=>u,frontMatter:()=>a,metadata:()=>t,toc:()=>c});const t=JSON.parse('{"id":"youtube-code/video-1","title":"video-1","description":"\x3c!--","source":"@site/docs/youtube-code/video-1.mdx","sourceDirName":"youtube-code","slug":"/youtube-code/video-1","permalink":"/docs/youtube-code/video-1","draft":false,"unlisted":false,"tags":[],"version":"current","sidebarPosition":2,"frontMatter":{"sidebar_position":2},"sidebar":"tutorialSidebar","previous":{"title":"YouTube Code","permalink":"/docs/intro"}}');var r=o(4848),i=o(8453);const a={sidebar_position:2},l="Video #1",s={},c=[{value:"YouTube Video",id:"youtube-video",level:2},{value:"Screen Map",id:"screen-map",level:2},{value:"Indicator Code",id:"indicator-code",level:2},{value:"Nightshark Code",id:"nightshark-code",level:2},{value:"Notes",id:"notes",level:2}];function d(n){const e={code:"code",h1:"h1",h2:"h2",header:"header",hr:"hr",li:"li",p:"p",pre:"pre",ul:"ul",...(0,i.R)(),...n.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(e.header,{children:(0,r.jsx)(e.h1,{id:"video-1",children:"Video #1"})}),"\n",(0,r.jsx)(e.p,{children:"Brief description of what this video covers and what viewers will learn."}),"\n",(0,r.jsx)(e.h2,{id:"youtube-video",children:"YouTube Video"}),"\n",(0,r.jsx)("div",{style:{textAlign:"center",margin:"2rem 0"},children:(0,r.jsx)("iframe",{width:"100%",height:"617",src:"https://www.youtube.com/embed/yKKjG_o63u4",title:"YouTube video player",frameBorder:"0",allow:"accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share",allowFullScreen:!0,style:{maxWidth:"1097px",width:"100%",aspectRatio:"16/9",border:"none"}})}),"\n",(0,r.jsx)(e.h2,{id:"screen-map",children:"Screen Map"}),"\n",(0,r.jsx)(e.h2,{id:"indicator-code",children:"Indicator Code"}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-python",children:"//@version=6\nindicator(\"Machine Learning Moving Average [LuxAlgo]\", \"LuxAlgo - Machine Learning Moving Average\", overlay=true)\n//---------------------------------------------------------------------------------------------------------------------\n// Settings\n//---------------------------------------------------------------------------------------------------------------------\nwindow   = input.int(100, minval=0)\nforecast = input.int(0)\nsigma    = input.float(0.01, step=0.1, minval=0)\n\nmult = input.float(2, 'Multiplicative Factor', minval=0)\nsrc  = input.source(close, 'Source')\n\n// Style\nupCss   = input.color(color.new(#5b9cf6, 50), 'Upper Extremity', group='Style')\ndnCss   = input.color(color.new(#e91e63, 50), 'Lower Extremity', group='Style')\n\nbullCss = input.color(#3179f5, 'Moving Average', inline='ma', group='Style')\nbearCss = input.color(#e91e63, '', inline='ma', group='Style')\n\n//---------------------------------------------------------------------------------------------------------------------\n// Functions\n//---------------------------------------------------------------------------------------------------------------------\nrbf(x1, x2, l) => math.exp(-math.pow(x1 - x2, 2) / (2.0 * math.pow(l, 2)))\n\nkernel_matrix(X1, X2, l) =>\n    km = matrix.new<float>(array.size(X1), array.size(X2))\n\n    i = 0\n    for x1 in X1\n        j = 0\n        for x2 in X2\n            rbf_val = rbf(x1, x2, l)\n            matrix.set(km, i, j, rbf_val)\n            j += 1\n        i += 1\n    km\n\n//---------------------------------------------------------------------------------------------------------------------\n// Kernel Setup\n//---------------------------------------------------------------------------------------------------------------------\nvar identity = matrix.new<int>(window, window, 0)\nvar K_row = array.new_float(0)\n\nif barstate.isfirst\n    var xtrain = array.new_int(0)\n    var xtest  = array.new_int(0)\n\n    // Build identity matrix and training array\n    for i = 0 to window - 1\n        for j = 0 to window - 1\n            matrix.set(identity, i, j, i == j ? 1 : 0)\n        array.push(xtrain, i)\n    \n    // Build testing array\n    for i = 0 to window + forecast - 1\n        array.push(xtest, i)\n    \n    // Compute kernel matrices\n    s      = matrix.mult(identity, sigma * sigma)\n    Ktrain = matrix.sum(kernel_matrix(xtrain, xtrain, window), s)\n    K_inv  = matrix.pinv(Ktrain)\n    K_star = kernel_matrix(xtrain, xtest, window)\n    // Multiply the transpose of K_star by K_inv and get the (window+forecast-1)th row as an array\n    K_row_temp = matrix.row(matrix.mult(matrix.transpose(K_star), K_inv), window + forecast - 1)\n    // Copy the computed row to K_row\n    for i = 0 to array.size(K_row_temp) - 1\n        array.push(K_row, array.get(K_row_temp, i))\n\n//---------------------------------------------------------------------------------------------------------------------\n// Moving Average Calculation\n//---------------------------------------------------------------------------------------------------------------------\nvar os = 0\n\nmean = ta.sma(src, window)\n\n// Get end point estimate\nvar float out = na\n\nif bar_index > window\n    dotprod = 0.0\n    // Dot product between last K_row and training data\n    for i = 0 to window - 1\n        dotprod += array.get(K_row, i) * (src[window - 1 - i] - mean)\n    // Output\n    out := dotprod + mean\n\nmae   = ta.sma(math.abs(src - out), window) * mult\nupper = out + mae\nlower = out - mae\n\nos := close > upper and out > out[1] ? 1 : close < lower and out < out[1] ? 0 : os\n\n//---------------------------------------------------------------------------------------------------------------------\n// Plotting\n//---------------------------------------------------------------------------------------------------------------------\nplot_out = plot(out, 'End Point GPR', color = os == 1 ? bullCss : bearCss)\nplot_change = plot(os != os[1] ? out : na, 'Circle', color = os == 1 ? bullCss : bearCss, linewidth = 3, style = plot.style_circles)\nplot_upper  = plot(upper, 'Upper', color = na)\nplot_lower  = plot(lower, 'Lower', color = na)\n\nfill(plot_upper, plot_out, out + mae, out, upCss, color.new(chart.bg_color, 100))\nfill(plot_out, plot_lower, out, out - mae, color.new(chart.bg_color, 100), dnCss)\n\n//---------------------------------------------------------------------------------------------------------------------\n// Table Setup\n//---------------------------------------------------------------------------------------------------------------------\n// Create a table with 2 columns and 1 row in the top-right corner\nvar table signalTable = table.new(position.top_right, 2, 1, border_width = 1, frame_color = color.black)\n\n// Determine the signal text\nsignalText = close > upper and out > out[1] ? \"BUY\" : close < lower and out < out[1] ? \"SELL\" : \"NONE\"\n\n// Set background color: green for BUY, red for SELL, white for NONE\nbgColor    = close > upper and out > out[1] ? color.green : close < lower and out < out[1] ? color.red : color.white\n\n// Set text color: white for BUY/SELL, black for NONE\ntextColor  = close > upper and out > out[1] ? color.white : close < lower and out < out[1] ? color.white : color.black\n\n// Update table cells on every bar\ntable.cell(signalTable, 0, 0, \"SIGNAL\", text_color = color.white, text_size = size.large, bgcolor = color.gray)\ntable.cell(signalTable, 1, 0, signalText, text_color = textColor, text_size = size.large, bgcolor = bgColor)\n"})}),"\n",(0,r.jsx)(e.h2,{id:"nightshark-code",children:"Nightshark Code"}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-javascript",children:';Machine learning Moving Average Code\n\n\nStopScript() {\n    Send, {F2}\n}\n\nBUY_condition() {\n    global\n    return (area[1] ~= "BUY")\n}\n\nSELL_condition() {\n    global\n    return (area[1] ~= "SELL")\n}\n\nlongPosition:= 0\nshortPosition := 0\nloop {\n    loop{\n    read_areas()\n    } until (BUY_condition() || SELL_condition() )\n\n    if(BUY_condition() && longPosition <> 1) {\n        if(shortPosition = 1) {\n            click(point.a)\n            shortPosition:= 0\n            click(point.c)\n        }\n        else {\n            click(point.a)\n            longPosition := 1\n            click(point.c)\n        }\n    }\n\n    else if(SELL_condition() && shortPosition <> 1 ) {\n        if(longPosition = 1) {\n            click(point.b)\n            longPosition := 0\n            click(point.c)\n        }\n        else {\n            click(point.b)\n            shortPosition := 1\n            click(point.c)\n        }\n    }\n}\n'})}),"\n",(0,r.jsx)(e.hr,{}),"\n",(0,r.jsx)(e.h2,{id:"notes",children:"Notes"}),"\n",(0,r.jsxs)(e.ul,{children:["\n",(0,r.jsx)(e.li,{children:"Add any additional notes, tips, or important information here"}),"\n",(0,r.jsx)(e.li,{children:"Link to related resources if needed"}),"\n",(0,r.jsx)(e.li,{children:"Include any prerequisites or setup instructions"}),"\n"]})]})}function u(n={}){const{wrapper:e}={...(0,i.R)(),...n.components};return e?(0,r.jsx)(e,{...n,children:(0,r.jsx)(d,{...n})}):d(n)}},8453:(n,e,o)=>{o.d(e,{R:()=>a,x:()=>l});var t=o(6540);const r={},i=t.createContext(r);function a(n){const e=t.useContext(i);return t.useMemo(function(){return"function"==typeof n?n(e):{...e,...n}},[e,n])}function l(n){let e;return e=n.disableParentContext?"function"==typeof n.components?n.components(r):n.components||r:a(n.components),t.createElement(i.Provider,{value:e},n.children)}}}]);